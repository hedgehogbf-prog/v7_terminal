# psu/gui.py
"""
Графическая панель управления ЛБП (Owon PSU) для v7_terminal.

Функции:
- Выбор COM-порта + подключение/отключение
- Большие индикаторы измеренного U/I
- Маленькие поля для установки U_set / I_set и кнопка "Применить"
- Кнопка включения/выключения выхода
- Кнопка Reset COM (переоткрыть порт)
- Пресеты (U/I) с возможностью редактирования и сохранением в JSON
"""

import json
import os
from tkinter import (
    Frame, Label, Button, Entry, StringVar, LEFT, RIGHT, TOP, BOTTOM,
    X, Y, BOTH, Toplevel, Listbox, SINGLE, END
)
from tkinter import font as tkfont
from tkinter import ttk

from serial.tools import list_ports

from psu.owon import OwonPSU


# где хранить пресеты
DEFAULT_PRESETS_PATH = os.path.join(
    os.path.dirname(r"C:\\Users\\Flashchine\\Documents\\v7\\logs"),
    "lbp_presets.json"
)

DEFAULT_PRESETS = {
    "0V 0A": {"U": 0.0, "I": 0.0},
    "5V 1A": {"U": 5.0, "I": 1.0},
    "12V 3A": {"U": 12.0, "I": 3.0},
}


class PSUControlPanel(Frame):
    POLL_INTERVAL_MS = 200

    def __init__(self, master, bg="#202124", fg="#e8eaed", **kwargs):
        super().__init__(master, bg=bg, **kwargs)
        self.bg = bg
        self.fg = fg

        self.psu = OwonPSU()
        self._poll_running = False

        # значения
        self.port_var = StringVar(value="")
        self.u_set_var = StringVar(value="0.0")
        self.i_set_var = StringVar(value="0.0")
        self.u_meas_var = StringVar(value="0.00")
        self.i_meas_var = StringVar(value="0.000")
        self.output_on = False

        # пресеты
        self.presets_path = DEFAULT_PRESETS_PATH
        self.presets: dict[str, dict] = {}
        self._load_presets()

        # шрифты
        self.font_big = tkfont.Font(size=24, weight="bold")
        self.font_mid = tkfont.Font(size=12)
        self.font_small = tkfont.Font(size=10)

        self._build_ui()
        self._schedule_poll()

    # ------------------- UI -------------------

    def _build_ui(self):
        # верх: выбор порта и подключение
        top = Frame(self, bg=self.bg)
        top.pack(side=TOP, fill=X, padx=4, pady=4)

        Label(top, text="ЛБП:", bg=self.bg, fg=self.fg).pack(side=LEFT, padx=(0, 4))

        self.combo_port = ttk.Combobox(top, textvariable=self.port_var, width=10, state="readonly")
        self.combo_port.pack(side=LEFT, padx=2)
        self._refresh_ports()

        btn_refresh = Button(
            top, text="Обновить", command=self._refresh_ports,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        btn_refresh.pack(side=LEFT, padx=2)

        self.btn_connect = Button(
            top, text="Подключить", command=self._toggle_connect,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        self.btn_connect.pack(side=LEFT, padx=2)

        self.btn_reset = Button(
            top, text="Reset COM", command=self._reset_com,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        self.btn_reset.pack(side=LEFT, padx=2)

        self.lbl_identity = Label(top, text="Не подключено", bg=self.bg, fg=self.fg, anchor="w")
        self.lbl_identity.pack(side=LEFT, padx=8)

        # центральная область: слева измерения, справа установки + выход
        center = Frame(self, bg=self.bg)
        center.pack(side=TOP, fill=X, padx=4, pady=4)

        # измерения (большие цифры)
        meas_frame = Frame(center, bg=self.bg)
        meas_frame.pack(side=LEFT, fill=BOTH, expand=True, padx=(0, 8))

        Label(meas_frame, text="Измерено", bg=self.bg, fg=self.fg, font=self.font_small).pack(anchor="w")

        self.lbl_u_meas = Label(
            meas_frame, textvariable=self.u_meas_var,
            bg=self.bg, fg="#3aff3a", font=self.font_big
        )
        self.lbl_u_meas.pack(anchor="w")

        self.lbl_i_meas = Label(
            meas_frame, textvariable=self.i_meas_var,
            bg=self.bg, fg="#3aff3a", font=self.font_big
        )
        self.lbl_i_meas.pack(anchor="w")

        # установки
        set_frame = Frame(center, bg=self.bg)
        set_frame.pack(side=RIGHT, fill=Y)

        Label(set_frame, text="Установлено", bg=self.bg, fg=self.fg, font=self.font_small).pack(anchor="w")

        row_u = Frame(set_frame, bg=self.bg)
        row_u.pack(fill=X, pady=2)
        Label(row_u, text="U, В:", bg=self.bg, fg=self.fg, font=self.font_mid, width=6, anchor="w").pack(side=LEFT)
        self.entry_u_set = Entry(row_u, textvariable=self.u_set_var, width=8,
                                 bg="#303134", fg=self.fg, insertbackground=self.fg)
        self.entry_u_set.pack(side=LEFT, padx=2)

        row_i = Frame(set_frame, bg=self.bg)
        row_i.pack(fill=X, pady=2)
        Label(row_i, text="I, А:", bg=self.bg, fg=self.fg, font=self.font_mid, width=6, anchor="w").pack(side=LEFT)
        self.entry_i_set = Entry(row_i, textvariable=self.i_set_var, width=8,
                                 bg="#303134", fg=self.fg, insertbackground=self.fg)
        self.entry_i_set.pack(side=LEFT, padx=2)

        btn_apply = Button(
            set_frame, text="Применить", command=self._apply_setpoints,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        btn_apply.pack(fill=X, pady=(6, 2))

        self.btn_output = Button(
            set_frame, text="Выход: OFF", command=self._toggle_output,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        self.btn_output.pack(fill=X, pady=(2, 2))

        # пресеты
        presets_box = Frame(self, bg=self.bg)
        presets_box.pack(side=TOP, fill=BOTH, expand=True, padx=4, pady=(0, 4))

        header = Frame(presets_box, bg=self.bg)
        header.pack(side=TOP, fill=X)

        Label(header, text="Пресеты", bg=self.bg, fg=self.fg, font=self.font_small).pack(side=LEFT)

        btn_edit = Button(
            header, text="Редактировать", command=self._open_presets_editor,
            bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg
        )
        btn_edit.pack(side=RIGHT)

        self.presets_frame = Frame(presets_box, bg=self.bg)
        self.presets_frame.pack(side=TOP, fill=BOTH, expand=True)

        self._rebuild_preset_buttons()

    # ------------------- работа с портами -------------------

    def _refresh_ports(self):
        ports = list_ports.comports()
        names = [p.device for p in ports]
        self.combo_port["values"] = names
        if names and not self.port_var.get():
            self.port_var.set(names[0])

    def _toggle_connect(self):
        if self.psu.connected:
            self.psu.disconnect()
            self.btn_connect.config(text="Подключить")
            self.lbl_identity.config(text="Не подключено", fg=self.fg)
            return

        port = self.port_var.get().strip()
        if not port:
            self.lbl_identity.config(text="Порт не выбран", fg="#ff5555")
            return

        ok = self.psu.connect(port)
        if not ok:
            self.lbl_identity.config(text=f"Ошибка подключения к {port}", fg="#ff5555")
            return

        ident = self.psu.identify() or f"Подключено к {port}"
        self.lbl_identity.config(text=ident, fg=self.fg)
        self.btn_connect.config(text=f"Отключить")

    def _reset_com(self):
        """Принудительно закрыть и снова открыть выбранный порт."""
        port = self.port_var.get().strip()
        self.psu.disconnect()
        if not port:
            self.lbl_identity.config(text="Reset: порт не выбран", fg="#ff5555")
            return
        ok = self.psu.connect(port)
        if ok:
            ident = self.psu.identify() or f"Снова подключено к {port}"
            self.lbl_identity.config(text=ident, fg=self.fg)
            self.btn_connect.config(text=f"Отключить")
        else:
            self.lbl_identity.config(text=f"Reset: ошибка подключения к {port}", fg="#ff5555")

    # ------------------- опрос измерений -------------------

    def _schedule_poll(self):
        # планируем опрос каждые POLL_INTERVAL_MS
        self.after(self.POLL_INTERVAL_MS, self._poll_once)

    def _poll_once(self):
        if self.psu.connected:
            u, i = self.psu.read_measurements()
            if u is not None:
                self.u_meas_var.set(f"{u:6.3f} V")
            else:
                self.u_meas_var.set("--.-- V")
            if i is not None:
                self.i_meas_var.set(f"{i:6.3f} A")
            else:
                self.i_meas_var.set("--.-- A")
        self._schedule_poll()

    # ------------------- управление выходом и уставками -------------------

    def _apply_setpoints(self):
        try:
            u = float(self.u_set_var.get().replace(",", "."))
            i = float(self.i_set_var.get().replace(",", "."))
        except ValueError:
            self.lbl_identity.config(text="Неверный формат U/I", fg="#ff5555")
            return
        if not self.psu.connected:
            self.lbl_identity.config(text="ЛБП не подключен", fg="#ff5555")
            return
        self.psu.set_voltage_current(u, i)
        self.lbl_identity.config(text=f"U={u:.3f} В, I={i:.3f} А установлены", fg=self.fg)

    def _toggle_output(self):
        if not self.psu.connected:
            self.lbl_identity.config(text="ЛБП не подключен", fg="#ff5555")
            return
        self.output_on = not self.output_on
        self.psu.set_output(self.output_on)
        self.btn_output.config(text=f"Выход: {'ON' if self.output_on else 'OFF'}")

    # ------------------- пресеты -------------------

    def _load_presets(self):
        try:
            if os.path.exists(self.presets_path):
                with open(self.presets_path, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, dict):
                        self.presets = data
                        return
        except Exception:
            pass
        # если не удалось — дефолт
        self.presets = DEFAULT_PRESETS.copy()
        self._save_presets()

    def _save_presets(self):
        os.makedirs(os.path.dirname(self.presets_path), exist_ok=True)
        try:
            with open(self.presets_path, "w", encoding="utf-8") as f:
                json.dump(self.presets, f, ensure_ascii=False, indent=2)
        except Exception:
            pass

    def _rebuild_preset_buttons(self):
        # очистить старые кнопки
        for w in self.presets_frame.winfo_children():
            w.destroy()

        for name, cfg in self.presets.items():
            u = cfg.get("U", 0.0)
            i = cfg.get("I", 0.0)
            txt = f"{name}\nU={u:g}В  I={i:g}A"
            btn = Button(
                self.presets_frame, text=txt,
                command=lambda u=u, i=i: self._apply_preset(u, i),
                justify="left",
                anchor="w",
                bg="#303134", fg=self.fg,
                activebackground="#3c4043", activeforeground=self.fg,
                wraplength=180
            )
            btn.pack(fill=X, pady=2)

    def _apply_preset(self, u: float, i: float):
        self.u_set_var.set(f"{u:g}")
        self.i_set_var.set(f"{i:g}")
        # сразу применяем, если подключено
        if self.psu.connected:
            self._apply_setpoints()

    def _open_presets_editor(self):
        PresetsEditor(self, self.presets, self.presets_path, on_change=self._on_presets_changed)

    def _on_presets_changed(self, new_presets: dict):
        self.presets = new_presets
        self._save_presets()
        self._rebuild_preset_buttons()


class PresetsEditor(Toplevel):
    def __init__(self, master: PSUControlPanel, presets: dict, path: str, on_change):
        super().__init__(master)
        self.title("Редактор пресетов ЛБП")
        self.configure(bg=master.bg)
        self.presets = dict(presets)  # копия
        self.path = path
        self.on_change = on_change
        self.bg = master.bg
        self.fg = master.fg

        self.name_var = StringVar()
        self.u_var = StringVar()
        self.i_var = StringVar()

        self._build_ui()
        self._reload_list()

        self.grab_set()
        self.focus_set()

    def _build_ui(self):
        top = Frame(self, bg=self.bg)
        top.pack(side=TOP, fill=BOTH, expand=True, padx=8, pady=8)

        self.listbox = Listbox(top, selectmode=SINGLE, bg="#202124", fg=self.fg, width=28, height=10)
        self.listbox.pack(side=LEFT, fill=Y)
        self.listbox.bind("<<ListboxSelect>>", self._on_select)

        right = Frame(top, bg=self.bg)
        right.pack(side=RIGHT, fill=BOTH, expand=True, padx=(8, 0))

        row1 = Frame(right, bg=self.bg); row1.pack(fill=X, pady=2)
        Label(row1, text="Имя:", bg=self.bg, fg=self.fg).pack(side=LEFT)
        Entry(row1, textvariable=self.name_var, bg="#303134", fg=self.fg, insertbackground=self.fg).pack(side=LEFT, fill=X, expand=True)

        row2 = Frame(right, bg=self.bg); row2.pack(fill=X, pady=2)
        Label(row2, text="U, В:", bg=self.bg, fg=self.fg).pack(side=LEFT)
        Entry(row2, textvariable=self.u_var, bg="#303134", fg=self.fg, width=10, insertbackground=self.fg).pack(side=LEFT)

        row3 = Frame(right, bg=self.bg); row3.pack(fill=X, pady=2)
        Label(row3, text="I, А:", bg=self.bg, fg=self.fg).pack(side=LEFT)
        Entry(row3, textvariable=self.i_var, bg="#303134", fg=self.fg, width=10, insertbackground=self.fg).pack(side=LEFT)

        btns = Frame(right, bg=self.bg); btns.pack(fill=X, pady=(8, 0))
        Button(btns, text="Добавить/Обновить", command=self._add_or_update,
               bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg).pack(fill=X, pady=2)
        Button(btns, text="Удалить", command=self._delete_selected,
               bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg).pack(fill=X, pady=2)
        Button(btns, text="Закрыть", command=self._on_close,
               bg="#303134", fg=self.fg, activebackground="#3c4043", activeforeground=self.fg).pack(fill=X, pady=(8, 0))

    def _reload_list(self):
        self.listbox.delete(0, END)
        for name in self.presets.keys():
            self.listbox.insert(END, name)

    def _on_select(self, event=None):
        sel = self.listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        name = self.listbox.get(idx)
        cfg = self.presets.get(name, {})
        self.name_var.set(name)
        self.u_var.set(str(cfg.get("U", 0.0)))
        self.i_var.set(str(cfg.get("I", 0.0)))

    def _add_or_update(self):
        name = self.name_var.get().strip()
        if not name:
            return
        try:
            u = float(self.u_var.get().replace(",", "."))
            i = float(self.i_var.get().replace(",", "."))
        except ValueError:
            return
        self.presets[name] = {"U": u, "I": i}
        self._reload_list()

    def _delete_selected(self):
        sel = self.listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        name = self.listbox.get(idx)
        if name in self.presets:
            del self.presets[name]
            self._reload_list()

    def _on_close(self):
        if self.on_change:
            self.on_change(self.presets)
        self.destroy()
